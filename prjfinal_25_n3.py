# -*- coding: utf-8 -*-
"""prjFinal_25_n3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wJoOowUDwmmFR3AmXQNl0bX-WiowfpgW
"""

#criar ambiente de sessão spark em memoria
#instalando bibiloteca pyspark
!pip install pyspark

from pyspark.sql import SparkSession as ss
from pyspark.sql import functions as f
from pyspark.sql.types import DoubleType

#criando objeto spark
spark = ss.builder.appName("FILMES").getOrCreate()

#importando dataframe .csv
url= "/content/drive/MyDrive/BasesPark/DataSetsLetterBoxed/cleaned_movies.csv"
filmes = spark.read.csv(
    url,
    sep=",",
    header=True,
    inferSchema=True
)

filmes.show(10)

url= "/content/drive/MyDrive/BasesPark/DataSetsLetterBoxed/crew.csv"
elenco = spark.read.csv(
    url,
    sep=",",
    header=True,
    inferSchema=True
)

filmes.where("len(minute) >= 4").count()

url= "/content/drive/MyDrive/BasesPark/DataSetsLetterBoxed/genres.csv"
genero = spark.read.csv(
    url,
    sep=",",
    header=True,
    inferSchema=True
)

genero.show()

url= "/content/drive/MyDrive/BasesPark/DataSetsLetterBoxed/releases.csv"
lancamento = spark.read.csv(
    url,
    sep=",",
    header=True,
    inferSchema=True
)

lancamento.show()

url= "/content/drive/MyDrive/BasesPark/DataSetsLetterBoxed/actors.csv"
atores = spark.read.csv(
    url,
    sep=",",
    header=True,
    inferSchema=True
)

atores.show()

filmes.show(1)
atores.show(1)
genero.show(1)
elenco.show(1)
lancamento.show(1)

## renomeando colunas

filmes.withColumnsRenamed({
    "name" : "TITULO",
    "date" : "ANO_LANCAMENTO",
    "minute":"MINUTOS",
    "rating":"NOTA"
}).show()

atores.withColumnsRenamed({
    "name" : "NOME",
    "role" : "PAPEL"
}).show()

genero.withColumnsRenamed({
    "genre" : "GENERO"
}).show()

elenco.withColumnsRenamed({
    "role" : "FUNCAO"
}).show()

lancamento.withColumnsRenamed({
    "contry" : "PAIS",
    "date" : "DATA",
    "type" : "TIPO"
}).show()

filmes = filmes.withColumnsRenamed({
    "name" : "TITULO",
    "date" : "ANO_LANCAMENTO",
    "minute":"MINUTOS",
    "rating":"NOTA"
})

atores = atores.withColumnsRenamed({
    "name" : "NOME",
    "role" : "PAPEL"
})

genero = genero.withColumnsRenamed({
    "genre" : "GENERO"
})

elenco = elenco.withColumnsRenamed({
    "role" : "FUNCAO",
    "name" : "NOME"
})

lancamento = lancamento.withColumnsRenamed({
    "contry" : "PAIS",
    "date" : "DATA",
    "type" : "TIPO"
})

# todos os valores ja convertidos corretamente
# não tem necessidade de uma converção

lancamento.printSchema()

lancamento.show()

lancamento.drop("rating")

#criando as views
filmes.createOrReplaceTempView("v_filme")
atores.createOrReplaceTempView("v_atores")
elenco.createOrReplaceTempView("v_elenco")
lancamento.createOrReplaceTempView("v_lancamento")
genero.createOrReplaceTempView("v_genero")

#consulta qe mostra filmes seus diretores e as notas dos filmes ordenados dos mais bem avaliados
spark.sql(
"""
SELECT
    F.TITULO,
    E.NOME,
    F.NOTA
FROM V_ELENCO E
INNER JOIN V_FILME F ON E.ID = F.ID
WHERE E.FUNCAO = 'Director'
ORDER BY NOTA DESC
"""
).show(15,False)

#as maiores medias por diretores
#metodo ruim
spark.sql(
"""
SELECT
    E.NOME,
    AVG(F.NOTA) AS MEDIA_DAS_NOTAS
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE E.FUNCAO = 'Director'
GROUP BY E.NOME
ORDER BY MEDIA_DAS_NOTAS DESC
"""
).show(10)



#diretores com a maior quantidade de filmes com a nota maior de 4.5
#metodo melhor
spark.sql(
"""
SELECT
    E.NOME,
    COUNT(F.ID) AS QTD_FILMES_ALTA_NOTA
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE
    E.FUNCAO = 'Director' AND F.NOTA >= 4.5
GROUP BY
    E.NOME
ORDER BY
    QTD_FILMES_ALTA_NOTA DESC
"""
).show(10)

#calcula a mediana de cada diretor
#metodo ruim
spark.sql(
"""
SELECT
    E.NOME,
    percentile_approx(F.NOTA, 0.5) AS MEDIANA_DAS_NOTAS
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE
    E.FUNCAO = 'Director'
GROUP BY
    E.NOME
ORDER BY
    MEDIANA_DAS_NOTAS DESC
"""
).show(10)

elenco.show(10)

##decobrir quais são os roterista com a maior nota (media)
#metodo ruim
spark.sql(
"""
SELECT
    E.NOME,
    AVG(F.NOTA) AS MEDIA_DAS_NOTAS
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE E.FUNCAO = 'Writer'
GROUP BY E.NOME
ORDER BY MEDIA_DAS_NOTAS DESC
"""
).show(10)

#roterista com a maior quantidade de filmes com a nota maior de 4.5
#metodo melhor
spark.sql(
"""
SELECT
    E.NOME,
    COUNT(F.ID) AS QTD_FILMES_ALTA_NOTA
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE
    E.FUNCAO = 'Writer' AND F.NOTA >= 4.5
GROUP BY
    E.NOME
ORDER BY
    QTD_FILMES_ALTA_NOTA DESC
"""
).show(10)

#PAISES COM A MAIOR QUANTIDADE DE FILMES A COM A NOTA MAIOR OU IGUAL 4.5
spark.sql(
"""
SELECT
    L.country AS PAIS,
    COUNT(F.ID) AS QTD_FILMES_NOTA_ALTA
FROM V_FILME AS F
INNER JOIN V_LANCAMENTO AS L ON F.ID = L.ID
WHERE
    F.NOTA >= 4.5
GROUP BY
    L.country
ORDER BY
    QTD_FILMES_NOTA_ALTA DESC
"""
).show(10)



#OS FILMES BRASILEIROS COM AS MELHORES NOTAS
#concertar consulta
spark.sql(
"""
WITH Diretores AS (
  SELECT
    ID,
    NOME AS DIRETOR
  FROM V_ELENCO
  WHERE FUNCAO = 'Director'
),
Roteristas AS (
  SELECT
    ID,
    NOME AS ROTERISTA
  FROM V_ELENCO
  WHERE FUNCAO = 'Write'
)
SELECT
  F.TITULO,
  D.DIRETOR,
  R.ROTERISTA,
  F.NOTA,
  F.ANO_LANCAMENTO
FROM V_FILME AS F
INNER JOIN V_LANCAMENTO AS L ON F.ID = L.ID
LEFT JOIN Diretores AS D ON F.ID = D.ID
LEFT JOIN Roteristas AS R ON F.ID = R.ID
WHERE
  L.country = 'Brazil'
ORDER BY
  F.NOTA DESC
"""
).show(10)

#CONSULTAS COMEÇAM AQUI

#1. Ranking de Gêneros por Nota Média
#Esta consulta calcula a nota média para cada gênero de filme, permitindo identificar quais são os gêneros mais bem avaliados em geral.
spark.sql(
"""
SELECT
    G.GENERO,
    ROUND(AVG(F.NOTA), 2) AS MEDIA_DAS_NOTAS
FROM V_GENERO AS G
INNER JOIN V_FILME AS F ON G.ID = F.ID
GROUP BY G.GENERO
ORDER BY MEDIA_DAS_NOTAS DESC
"""
).show(20)

#2. Atores Mais Premiados (Filmes com Nota Alta)
spark.sql(
"""
SELECT
    A.NOME,
    COUNT(F.ID) AS QTD_FILMES_ALTA_NOTA
FROM V_ATORES AS A
INNER JOIN V_FILME AS F ON A.ID = F.ID
WHERE F.NOTA >= 4.5
GROUP BY A.NOME
ORDER BY QTD_FILMES_ALTA_NOTA DESC
"""
).show(50)

#3. Análise de Desempenho dos Diretores (Média de Notas e Quantidade de Filmes)minimo de 5 filmes para não sujar dados
#Aqui, a nota média dos filmes de cada diretor será arredondada para duas casas decimais.
spark.sql(
"""
SELECT
    E.NOME,
    ROUND(AVG(F.NOTA), 2) AS MEDIA_DAS_NOTAS,
    COUNT(F.ID) AS QTD_FILMES
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE E.FUNCAO = 'Director'
GROUP BY E.NOME
HAVING COUNT(F.ID) >= 5
ORDER BY MEDIA_DAS_NOTAS DESC
"""
).show(50)

#4. Produtores Mais Bem Avaliados (com no mínimo 5 filmes)
#Esta consulta irá listar os produtores, a nota média de seus filmes (arredondada para duas casas decimais) e a quantidade de filmes em que trabalharam, incluindo apenas aqueles com 5 ou mais filmes no currículo.
spark.sql(
"""
SELECT
    E.NOME,
    ROUND(AVG(F.NOTA), 2) AS MEDIA_DAS_NOTAS,
    COUNT(F.ID) AS QTD_FILMES
FROM V_ELENCO AS E
INNER JOIN V_FILME AS F ON E.ID = F.ID
WHERE E.FUNCAO = 'Producer'
GROUP BY E.NOME
HAVING COUNT(F.ID) >= 5
ORDER BY MEDIA_DAS_NOTAS DESC
"""
).show(50)

#5. Países com Maior Número de Lançamentos de Filmes de Sucesso

spark.sql(
"""
SELECT
    L.country AS PAIS,
    COUNT(DISTINCT F.ID) AS QTD_FILMES_NOTA_ALTA
FROM V_FILME AS F
INNER JOIN V_LANCAMENTO AS L ON F.ID = L.ID
WHERE F.NOTA >= 4.5
GROUP BY L.country
ORDER BY QTD_FILMES_NOTA_ALTA DESC
"""
).show(100)

#cosulta para .orc
spark.sql(
"""
SELECT
    F.TITULO,
    F.ANO_LANCAMENTO,
    F.NOTA,
    -- Agrupa todos os diretores de um filme em uma única linha
    COLLECT_LIST(D.NOME) AS DIRETORES,
    -- Seleciona o primeiro gênero da lista para simplificar
    FIRST(G.GENERO) AS GENERO_PRINCIPAL
FROM V_FILME AS F
-- Join para buscar o nome do diretor
LEFT JOIN (SELECT ID, NOME FROM V_ELENCO WHERE FUNCAO = 'Director') AS D ON F.ID = D.ID
-- Join para buscar o gênero
LEFT JOIN V_GENERO AS G ON F.ID = G.ID
-- Join para buscar o país de lançamento
LEFT JOIN V_LANCAMENTO AS L ON F.ID = L.ID
WHERE F.NOTA >= 4.5
GROUP BY F.TITULO, F.ANO_LANCAMENTO, F.NOTA
ORDER BY F.NOTA DESC
"""
).show(50)

# 1. Define a string com a consulta da análise complexa
query_analise_complexa = """
SELECT
    F.TITULO,
    F.ANO_LANCAMENTO,
    ROUND(F.NOTA, 2) AS NOTA,
    -- Agrupa todos os diretores de um filme em uma única linha
    COLLECT_LIST(D.NOME) AS DIRETORES,
    -- Seleciona o primeiro gênero da lista para simplificar
    FIRST(G.GENERO) AS GENERO_PRINCIPAL
FROM V_FILME AS F
-- Join para buscar o nome do diretor
LEFT JOIN (SELECT ID, NOME FROM V_ELENCO WHERE FUNCAO = 'Director') AS D ON F.ID = D.ID
-- Join para buscar o gênero
LEFT JOIN V_GENERO AS G ON F.ID = G.ID
-- Join para buscar o país de lançamento
LEFT JOIN V_LANCAMENTO AS L ON F.ID = L.ID
WHERE F.NOTA >= 4.5
GROUP BY F.TITULO, F.ANO_LANCAMENTO, F.NOTA
ORDER BY F.NOTA DESC
"""

# 2. Executa a consulta e cria o novo DataFrame
df_analise_complexa = spark.sql(query_analise_complexa)

# 3. Exibe as 10 primeiras linhas do DataFrame para verificação
print("Exibindo o DataFrame da análise complexa:")
df_analise_complexa.show(10, truncate=False)

# 4. Salva o DataFrame no formato ORC
# O mode("overwrite") garante que, se o diretório já existir, ele será substituído.
df_analise_complexa.write.mode("overwrite").orc("analise_complexa.orc")

print("\nDataFrame da análise complexa foi salvo com sucesso!")
print("O diretório 'analise_complexa.orc' foi criado com os arquivos no formato ORC.")